{"version":3,"sources":["node_modules/browser-pack/_prelude.js","set-functions.min.js","src/set-functions.js"],"names":["f","exports","module","define","amd","g","window","global","self","this","SetFunctions","e","t","n","r","s","o","u","a","require","i","Error","code","l","call","length","1","intersection","b","result","Set","has","forEach","item","add","union","difference","symmetricDifference","BreakException","isEqual","size","subtract","disjunction"],"mappings":"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","file":"set-functions.min.js","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","(function(f){if(typeof exports===\"object\"&&typeof module!==\"undefined\"){module.exports=f()}else if(typeof define===\"function\"&&define.amd){define([],f)}else{var g;if(typeof window!==\"undefined\"){g=window}else if(typeof global!==\"undefined\"){g=global}else if(typeof self!==\"undefined\"){g=self}else{g=this}g.SetFunctions = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){\n'use strict';\n\n/**\n * JavaScript Set operations\n *\n * All functions expect an ES6 Set type or a compatible polyfill to be available\n * in the global namespace.\n * @module set-functions\n */\n\n/*\n It seems that all methods of iteration (forEach, for-of, iterator) were\n approximately equal in performance, so I used forEach as it is the most\n widely supported.\n\n There are some platforms that provide Set but do not have all ES6 features\n (e.g. Set might be provided through a polyfill) so we do want to limit ES6\n features.\n\n Babel requires Symbol to transform for-of.\n\n Using ES6 modules is fine as browserify will handle this.\n\n See http://jsperf.com/set-iteration\n */\n\n/**\n * The set of items in a and b\n *\n * @param {Set} a\n * @param {Set} b\n * @returns {Set}\n */\nmodule.exports.intersection = function intersection(a, b) {\n  'use strict';\n\n  var result = new Set();\n\n  if (a && b) {\n    // should support b being an array\n    if (!b.has) {\n      b = new Set(b);\n    }\n\n    a.forEach(function (item) {\n      if (b.has(item)) {\n        result.add(item);\n      }\n    });\n  }\n\n  return result;\n};\n\n/**\n * The set of items in a or b\n *\n * @param {Set} a\n * @param {Set} b\n * @returns {Set}\n */\nmodule.exports.union = function union(a, b) {\n  'use strict';\n\n  var result = new Set(a);\n\n  if (b) {\n    b.forEach(function (item) {\n      result.add(item);\n    });\n  }\n\n  return result;\n};\n\n/**\n * The set of items in a but not in b\n *\n * @param {Set} a\n * @param {Set} b\n * @returns {Set}\n */\nmodule.exports.difference = function difference(a, b) {\n  'use strict';\n\n  if (!b) {\n    return new Set(a);\n  }\n\n  var result = new Set();\n\n  if (a) {\n\n    if (!b.has) {\n      b = new Set(b);\n    }\n\n    a.forEach(function (item) {\n      if (!b.has(item)) {\n        result.add(item);\n      }\n    });\n  }\n\n  return result;\n};\n\n/**\n * The set of items in a and b but not in their intersection.\n *\n * @param {Set} a\n * @param {Set} b\n * @returns {Set}\n */\nmodule.exports.symmetricDifference = function symmetricDifference(a, b) {\n  'use strict';\n\n  if (!b) {\n    return new Set(a);\n  }\n\n  var result = new Set();\n\n  if (a) {\n    if (!b.has) {\n      b = new Set(b);\n    }\n\n    if (!a.has) {\n      a = new Set(a);\n    }\n\n    a.forEach(function (item) {\n      if (!b.has(item)) {\n        result.add(item);\n      }\n    });\n\n    b.forEach(function (item) {\n      if (!a.has(item)) {\n        result.add(item);\n      }\n    });\n  }\n\n  return result;\n};\n\nvar BreakException = {};\n\n/**\n * Check set equality\n *\n * @param {Set} a\n * @param {Set} b\n * @returns {bool}\n */\nmodule.exports.isEqual = function isEqual(a, b) {\n  'use strict';\n\n  if (a === b) {\n    return true;\n  }\n  if (!a && !b) {\n    return true;\n  }\n  if (!a || !b) {\n    return false;\n  }\n  if (!a.has) {\n    a = new Set(a);\n  }\n  if (!b.has) {\n    b = new Set(b);\n  }\n\n  if (a.size != b.size) {\n    return false;\n  }\n\n  try {\n    a.forEach(function (item) {\n      if (!b.has(item)) {\n        // short-circuit by throwing on first difference\n        throw BreakException;\n      }\n    });\n  } catch (e) {\n    if (e === BreakException) {\n      return false;\n    } else {\n      // pass on any exceptions that we didn't generate\n      throw e;\n    }\n  }\n  return true;\n};\n\n/**\n * Alias for union\n *\n * @param {Set} a\n * @param {Set} b\n * @returns {Set}\n */\nmodule.exports.add = module.exports.union;\n\n/**\n * Alias for difference\n *\n * @param {Set} a\n * @param {Set} b\n * @returns {Set}\n */\nmodule.exports.subtract = module.exports.difference;\n\n/**\n * Alias for symmetric difference\n *\n * @param {Set} a\n * @param {Set} b\n * @returns {Set}\n */\nmodule.exports.disjunction = module.exports.symmetricDifference;\n\n},{}]},{},[1])(1)\n});\n\n","/**\n * JavaScript Set operations\n *\n * All functions expect an ES6 Set type or a compatible polyfill to be available\n * in the global namespace.\n * @module set-functions\n */\n\n/*\n It seems that all methods of iteration (forEach, for-of, iterator) were\n approximately equal in performance, so I used forEach as it is the most\n widely supported.\n\n There are some platforms that provide Set but do not have all ES6 features\n (e.g. Set might be provided through a polyfill) so we do want to limit ES6\n features.\n\n Babel requires Symbol to transform for-of.\n\n Using ES6 modules is fine as browserify will handle this.\n\n See http://jsperf.com/set-iteration\n */\n\n/**\n * The set of items in a and b\n *\n * @param {Set} a\n * @param {Set} b\n * @returns {Set}\n */\nmodule.exports.intersection = function intersection(a, b) {\n  'use strict';\n\n  var result = new Set();\n\n  if (a && b) {\n    // should support b being an array\n    if (!b.has) {\n      b = new Set(b);\n    }\n\n    a.forEach(function (item) {\n      if (b.has(item)) {\n        result.add(item);\n      }\n    });\n  }\n\n  return result;\n};\n\n/**\n * The set of items in a or b\n *\n * @param {Set} a\n * @param {Set} b\n * @returns {Set}\n */\nmodule.exports.union = function union(a, b) {\n  'use strict';\n\n  var result = new Set(a);\n\n  if (b) {\n    b.forEach(function (item) {\n      result.add(item);\n    });\n  }\n\n  return result;\n};\n\n/**\n * The set of items in a but not in b\n *\n * @param {Set} a\n * @param {Set} b\n * @returns {Set}\n */\nmodule.exports.difference = function difference(a, b) {\n  'use strict';\n\n  if (!b) {\n    return new Set(a);\n  }\n\n  var result = new Set();\n\n  if (a) {\n\n    if (!b.has) {\n      b = new Set(b);\n    }\n\n    a.forEach(function (item) {\n      if (!b.has(item)) {\n        result.add(item);\n      }\n    });\n  }\n\n  return result;\n};\n\n/**\n * The set of items in a and b but not in their intersection.\n *\n * @param {Set} a\n * @param {Set} b\n * @returns {Set}\n */\nmodule.exports.symmetricDifference = function symmetricDifference(a, b) {\n  'use strict';\n\n  if (!b) {\n    return new Set(a);\n  }\n\n  var result = new Set();\n\n  if (a) {\n    if (!b.has) {\n      b = new Set(b);\n    }\n\n    if (!a.has) {\n      a = new Set(a);\n    }\n\n    a.forEach(function (item) {\n      if (!b.has(item)) {\n        result.add(item);\n      }\n    });\n\n    b.forEach(function (item) {\n      if (!a.has(item)) {\n        result.add(item);\n      }\n    });\n  }\n\n  return result;\n};\n\nvar BreakException = {};\n\n/**\n * Check set equality\n *\n * @param {Set} a\n * @param {Set} b\n * @returns {bool}\n */\nmodule.exports.isEqual = function isEqual(a, b) {\n  'use strict';\n\n  if (a === b) {\n    return true;\n  }\n  if (!a && !b) {\n    return true;\n  }\n  if (!a || !b) {\n    return false;\n  }\n  if (!a.has) {\n    a = new Set(a);\n  }\n  if (!b.has) {\n    b = new Set(b);\n  }\n\n  if (a.size != b.size) {\n    return false;\n  }\n\n  try {\n    a.forEach(function (item) {\n      if (!b.has(item)) {\n        // short-circuit by throwing on first difference\n        throw BreakException\n      }\n    });\n  } catch (e) {\n    if (e === BreakException) {\n      return false;\n    } else {\n      // pass on any exceptions that we didn't generate\n      throw e;\n    }\n  }\n  return true;\n};\n\n/**\n * Alias for union\n *\n * @param {Set} a\n * @param {Set} b\n * @returns {Set}\n */\nmodule.exports.add = module.exports.union;\n\n/**\n * Alias for difference\n *\n * @param {Set} a\n * @param {Set} b\n * @returns {Set}\n */\nmodule.exports.subtract = module.exports.difference;\n\n/**\n * Alias for symmetric difference\n *\n * @param {Set} a\n * @param {Set} b\n * @returns {Set}\n */\nmodule.exports.disjunction = module.exports.symmetricDifference;\n"],"sourceRoot":"/source/"}